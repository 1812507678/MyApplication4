apply plugin: 'com.android.application'
//apply plugin: 'com.android.library'
//获取时间戳
def getDate() {
    def date = new Date()
    def formattedDate = date.format('yyyyMMddHHmm')
    return formattedDate
}

dependencies {
    compile fileTree(include: '*.jar', dir: 'libs')
    //compile project(':DroidPlugin')
    compile project(':IAdPlugin')
    compile 'org.jbundle.util.osgi.wrapped:org.jbundle.util.osgi.wrapped.org.apache.http.client:4.1.2'
    // 依赖的aar
    compile(name:'droid-plugin-v1.0.0', ext:'aar')
}

android {

    packagingOptions {
        /*exclude 'META-INF/LICENSE.txt'
        exclude 'META-INFTICE.txt'
        exclude 'META-INF/maven/com.squareup.okio/okio/pom.xml'
        exclude 'META-INF/maven/com.squareup.okio/okio/pom.properties'*/
    }

    compileSdkVersion 22
    buildToolsVersion "22.0.1"

    defaultConfig {
        applicationId 'com.ctsk.service'
        minSdkVersion 11
        targetSdkVersion 22
        versionCode 1
        versionName "1.0.0"
        //multiDexEnabled true
    }

    lintOptions {
        abortOnError false
    }

    //修改生成的apk名字
    applicationVariants.all { variant ->
        variant.outputs.each { output ->
            def oldFile = output.outputFile
            def projectName = 'JpAdSDK_v';
            def buildTypeRelease = 'release';
            def buildTypeBeta = 'beta';
            def buildTypeDebug = 'debug';
            def dateTime = getDate();
            if (variant.buildType.name.equals(buildTypeRelease)) {
                //println(variant.productFlavors[0].name)
                def releaseApkName = projectName + defaultConfig.versionName + '_' + variant.productFlavors[0].name + "_" + buildTypeRelease + "_" + dateTime + '.apk'
                output.outputFile = new File(oldFile.parent, releaseApkName)
            }
            if (variant.buildType.name.equals(buildTypeBeta)) {
                def releaseApkName = projectName + defaultConfig.versionName + '_' + variant.productFlavors[0].name + "_" + buildTypeBeta + "_" + dateTime + '.apk'
                output.outputFile = new File(oldFile.parent, releaseApkName)
            }
            if (variant.buildType.name.equals(buildTypeDebug)) {
                def releaseApkName = projectName + defaultConfig.versionName + '_' + variant.productFlavors[0].name + "_" + buildTypeDebug + '.apk'
                output.outputFile = new File(oldFile.parent, releaseApkName)
            }
        }
    }

    sourceSets {
        main {
            manifest.srcFile 'AndroidManifest.xml'
            java.srcDirs = ['src', 'test']
            resources.srcDirs = ['src', 'test']
            aidl.srcDirs = ['src', 'test']
            renderscript.srcDirs = ['src', 'test']
            res.srcDirs = ['res']
            assets.srcDirs = ['assets']
            jniLibs.srcDirs = ['libs']
        }

        // Move the tests to tests/java, tests/res, etc...
        instrumentTest.setRoot('tests')

        // Move the build types to build-types/<type>
        // For instance, build-types/debug/java, build-types/debug/AndroidManifest.xml, ...
        // This moves them out of them default location under src/<type>/... which would
        // conflict with src/ being used by the main source set.
        // Adding new build types or product flavors should be accompanied
        // by a similar customization.
        debug.setRoot('build-types/debug')
        release.setRoot('build-types/release')
    }

    //配置keystore签名
    /*signingConfigs {
        release {
            //该路径需要替换成自己本地的签名文件路径， 同时打开buildTypes里面的signingConfigs，
            // 这样就可以直接带签名跑起来了，这是为了调试有些需要签名才能调用的问题（如第三方登录需要签名才能调用）
            //在config.properties定义下面的变量
            //签名，这里的文件名和密码是错的，后面还会有从外部导入的语句
            storeFile file(key_store)
            storePassword key_store_password
            keyAlias key_alias
            keyPassword key_alias_password
        }
    }*/

    /*buildTypes {
        release {
            signingConfig signingConfigs.release
            // 是否进行混淆
            minifyEnabled true
            // 混淆文件的位置
            proguardFiles 'proguard-rules.pro'
        }
        beta {
            signingConfig signingConfigs.release
            // 是否进行混淆
            minifyEnabled true
            // 混淆文件的位置
            proguardFiles 'proguard-rules.pro'
        }
        debug {
            signingConfig signingConfigs.release
            // 是否进行混淆
            minifyEnabled false
            // 混淆文件的位置
            proguardFiles 'proguard-rules.pro'
        }
    }*/

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }

    //批量多渠道打包
    productFlavors {
        appstore {
            manifestPlaceholders = [jp_ad_channel: "appstore", jp_support_folder: 0, jp_support_icon: 0, jp_support_cbad: 1]
        }
    }

    /*dexOptions {
        //jumboMode true
        //incremental true
        javaMaxHeapSize "4g"
    }*/
}

/**
 * 这意味着系统将在libs目录下搜索依赖
 * this way we can find the .aar file in libs folder
 */
repositories {
    flatDir { dirs 'libs' }
}
